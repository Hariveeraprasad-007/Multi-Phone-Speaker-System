<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéµ Ultra-Low Latency Audio Sync</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 15px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            overflow-x: hidden;
            font-size: 14px;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 420px;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        h1 {
            font-size: 1.8rem;
            margin: 0 0 5px;
            background: linear-gradient(45deg, #fff, #f0f8ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            opacity: 0.8;
            margin-bottom: 20px;
            font-size: 0.9rem;
            font-weight: 300;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        button.connected {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }
        
        button.primary {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 15px 0;
        }
        
        .metric {
            background: rgba(0, 0, 0, 0.2);
            padding: 12px 8px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric-label {
            font-size: 0.75rem;
            opacity: 0.8;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .metric-value {
            font-size: 1.1rem;
            font-weight: bold;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 5px;
            animation: pulse 1s infinite;
        }
        
        .status-good { background: #4CAF50; }
        .status-warning { background: #FF9800; }
        .status-error { background: #F44336; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }
        
        .audio-visualizer {
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 15px 0;
            display: flex;
            align-items: end;
            justify-content: center;
            gap: 1px;
            padding: 8px;
            overflow: hidden;
        }
        
        .visualizer-bar {
            width: 4px;
            background: linear-gradient(to top, #4CAF50, #81C784);
            border-radius: 2px 2px 0 0;
            transition: height 0.05s ease-out;
            min-height: 1px;
        }
        
        .volume-control {
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 12px;
        }
        
        .volume-label {
            font-size: 0.9rem;
            margin-bottom: 8px;
            opacity: 0.9;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            margin: 8px 0;
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        
        .status-log {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.75rem;
            max-height: 80px;
            overflow-y: auto;
            margin-top: 15px;
            text-align: left;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.75rem;
            padding: 4px 8px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        @media (max-width: 500px) {
            .container {
                margin: 10px;
                padding: 20px 15px;
            }
            
            h1 { font-size: 1.5rem; }
            
            .metrics-grid {
                grid-template-columns: 1fr;
                gap: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="connection-status" id="connectionStatus">Offline</div>
        
        <h1>Audio Sync</h1>
        <div class="subtitle">Ultra-Low Latency</div>
        
        <div class="controls">
            <button id="enableAudioBtn" class="primary">üéµ Enable Audio</button>
            <button id="connectBtn">üîó Connect</button>
            <button id="disconnectBtn" disabled>‚èπÔ∏è Disconnect</button>
        </div>
        
        <div class="volume-control">
            <div class="volume-label">Volume: <span id="volumeValue">75%</span></div>
            <input type="range" id="volumeSlider" min="0" max="100" value="75">
        </div>
        
        <div class="audio-visualizer" id="visualizer"></div>
        
        <div class="metrics-grid">
            <div class="metric">
                <div class="metric-label">Status</div>
                <div class="metric-value" id="status">
                    Disconnected
                    <span class="status-indicator status-error"></span>
                </div>
            </div>
            <div class="metric">
                <div class="metric-label">Latency</div>
                <div class="metric-value" id="latency">-- ms</div>
            </div>
            <div class="metric">
                <div class="metric-label">Buffer</div>
                <div class="metric-value" id="buffer">--</div>
            </div>
            <div class="metric">
                <div class="metric-label">Quality</div>
                <div class="metric-value" id="quality">--</div>
            </div>
        </div>
        
        <div class="status-log" id="statusLog">
            Ultra-low latency audio sync ready...
        </div>
    </div>

    <script>
        class UltraLowLatencyAudioClient {
            constructor() {
                this.ws = null;
                this.audioContext = null;
                this.clientId = null;
                this.volume = 0.75;
                this.isConnected = false;
                this.audioEnabled = false;
                
                // Ultra-low latency settings
                this.sampleRate = 48000;
                this.targetBufferSize = 3; // Minimal buffer
                this.maxBufferSize = 8;
                this.audioBuffer = [];
                this.isProcessing = false;
                
                // Timing precision
                this.serverTimeOffset = 0;
                this.latency = 0;
                this.clockSyncSamples = [];
                this.lastSequence = -1;
                this.packetsReceived = 0;
                this.packetsLost = 0;
                
                // Performance optimization
                this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.useWebAssembly = false; // Could be enabled for even better performance
                
                this.initializeUI();
                this.initializeVisualizer();
            }
            
            initializeUI() {
                this.enableAudioBtn = document.getElementById('enableAudioBtn');
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.statusElement = document.getElementById('status');
                this.statusLog = document.getElementById('statusLog');
                this.latencyElement = document.getElementById('latency');
                this.bufferElement = document.getElementById('buffer');
                this.qualityElement = document.getElementById('quality');
                this.volumeSlider = document.getElementById('volumeSlider');
                this.volumeValue = document.getElementById('volumeValue');
                this.connectionStatus = document.getElementById('connectionStatus');
                
                // Event listeners
                this.enableAudioBtn.onclick = () => this.enableAudio();
                this.connectBtn.onclick = () => this.connect();
                this.disconnectBtn.onclick = () => this.disconnect();
                
                this.volumeSlider.oninput = (e) => {
                    this.volume = e.target.value / 100;
                    this.volumeValue.textContent = e.target.value + '%';
                };
            }
            
            initializeVisualizer() {
                this.visualizer = document.getElementById('visualizer');
                this.visualizerBars = [];
                
                const barCount = this.isMobile ? 16 : 24;
                for (let i = 0; i < barCount; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'visualizer-bar';
                    bar.style.height = '1px';
                    this.visualizer.appendChild(bar);
                    this.visualizerBars.push(bar);
                }
            }
            
            async enableAudio() {
                this.log("Initializing ultra-low latency audio...");
                
                try {
                    // Create optimized audio context
                    const contextOptions = {
                        sampleRate: this.sampleRate,
                        latencyHint: 'interactive'
                    };
                    
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)(contextOptions);
                    
                    // Resume if suspended
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    if (this.audioContext.state === 'running') {
                        this.audioEnabled = true;
                        this.enableAudioBtn.disabled = true;
                        this.enableAudioBtn.textContent = '‚úì Audio Ready';
                        this.enableAudioBtn.classList.add('connected');
                        this.connectBtn.disabled = false;
                        
                        // Start audio processing loop
                        this.startAudioProcessing();
                        
                        this.log(`Audio ready: ${this.audioContext.sampleRate}Hz, target latency: ${Math.round(this.targetBufferSize * 1000 / this.sampleRate * 256)}ms`);
                        
                    } else {
                        throw new Error(`Audio context state: ${this.audioContext.state}`);
                    }
                } catch (error) {
                    this.log(`Audio failed: ${error.message}`);
                    this.enableAudioBtn.textContent = '‚ùå Retry Audio';
                }
            }
            
            startAudioProcessing() {
                // High-frequency audio processing for minimal latency
                const processLoop = () => {
                    if (!this.audioEnabled) return;
                    
                    try {
                        this.processAudioBuffer();
                        this.updateMetrics();
                    } catch (error) {
                        console.error('Audio processing error:', error);
                    }
                    
                    if (this.audioEnabled) {
                        // Use requestAnimationFrame for smooth processing
                        requestAnimationFrame(processLoop);
                    }
                };
                
                processLoop();
            }
            
            processAudioBuffer() {
                if (this.audioBuffer.length === 0 || this.isProcessing) return;
                
                // Remove excess buffer to maintain low latency
                while (this.audioBuffer.length > this.maxBufferSize) {
                    this.audioBuffer.shift();
                }
                
                // Play if we have minimum buffer
                if (this.audioBuffer.length >= this.targetBufferSize) {
                    this.playNextAudioChunk();
                }
            }
            
            async playNextAudioChunk() {
                if (this.isProcessing || this.audioBuffer.length === 0) return;
                
                this.isProcessing = true;
                
                try {
                    const chunk = this.audioBuffer.shift();
                    if (chunk && chunk.audioData) {
                        await this.playAudioChunk(chunk);
                    }
                } catch (error) {
                    console.error('Playback error:', error);
                } finally {
                    this.isProcessing = false;
                }
            }
            
            async playAudioChunk(chunk) {
                try {
                    const { audioData, sampleRate, channels, timestamp } = chunk;
                    
                    // Decode binary audio data
                    const samples = new Float32Array(audioData.buffer);
                    const samplesPerChannel = samples.length / channels;
                    
                    if (samplesPerChannel <= 0) return;
                    
                    // Create audio buffer with precise timing
                    const audioBuffer = this.audioContext.createBuffer(
                        channels, 
                        samplesPerChannel, 
                        sampleRate
                    );
                    
                    // Fill channels with volume control
                    for (let channel = 0; channel < channels; channel++) {
                        const channelData = audioBuffer.getChannelData(channel);
                        for (let i = 0; i < samplesPerChannel; i++) {
                            channelData[i] = samples[i * channels + channel] * this.volume;
                        }
                    }
                    
                    // Schedule for immediate playback (minimal latency)
                    const currentTime = this.audioContext.currentTime;
                    const playTime = currentTime + 0.005; // 5ms ahead
                    
                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(this.audioContext.destination);
                    source.start(playTime);
                    
                    // Update visualizer
                    this.updateVisualizer(samples);
                    
                } catch (error) {
                    console.error('Chunk playback error:', error);
                }
            }
            
            connect() {
                if (!this.audioEnabled && this.isMobile) {
                    this.log("Please enable audio first");
                    return;
                }
                
                this.log("Connecting to server...");
                
                const wsUrl = `ws://${window.location.hostname}:8765`;
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        this.log("Connected! Ultra-low latency mode active");
                        this.updateConnectionStatus('Connected');
                        this.connectBtn.disabled = true;
                        this.disconnectBtn.disabled = false;
                        this.connectBtn.classList.add('connected');
                        
                        // Start ping loop for latency measurement
                        this.startLatencyMeasurement();
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            if (event.data instanceof ArrayBuffer) {
                                this.handleBinaryMessage(event.data);
                            } else {
                                const data = JSON.parse(event.data);
                                this.handleServerMessage(data);
                            }
                        } catch (error) {
                            console.error('Message handling error:', error);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        this.isConnected = false;
                        this.log("Disconnected from server");
                        this.updateConnectionStatus('Disconnected');
                        this.connectBtn.disabled = false;
                        this.disconnectBtn.disabled = true;
                        this.connectBtn.classList.remove('connected');
                        this.stopLatencyMeasurement();
                    };
                    
                    this.ws.onerror = () => {
                        this.log("Connection failed");
                        this.updateConnectionStatus('Error');
                    };
                    
                } catch (error) {
                    this.log(`Connection error: ${error.message}`);
                }
            }
            
            disconnect() {
                if (this.ws) {
                    this.ws.close();
                }
                this.audioBuffer = [];
                this.stopLatencyMeasurement();
            }
            
            handleBinaryMessage(arrayBuffer) {
                try {
                    // Parse binary audio data
                    const view = new DataView(arrayBuffer);
                    let offset = 0;
                    
                    // Read header
                    const type = view.getUint8(offset); offset += 1;
                    if (type !== 1) return; // Not audio data
                    
                    const sequence = view.getUint32(offset, false); offset += 4;
                    const timestamp = view.getFloat64(offset, false); offset += 8;
                    const serverTime = view.getFloat64(offset, false); offset += 8;
                    const sampleRate = view.getUint32(offset, false); offset += 4;
                    const channels = view.getUint8(offset); offset += 1;
                    const dataLength = view.getUint32(offset, false); offset += 4;
                    
                    // Check for lost packets
                    if (this.lastSequence >= 0 && sequence > this.lastSequence + 1) {
                        this.packetsLost += (sequence - this.lastSequence - 1);
                    }
                    this.lastSequence = sequence;
                    this.packetsReceived++;
                    
                    // Extract audio data
                    const audioData = arrayBuffer.slice(offset);
                    
                    // Add to buffer
                    const audioChunk = {
                        sequence,
                        timestamp,
                        serverTime,
                        sampleRate,
                        channels,
                        audioData: new Uint8Array(audioData)
                    };
                    
                    // Maintain buffer size for low latency
                    if (this.audioBuffer.length >= this.maxBufferSize) {
                        this.audioBuffer.shift(); // Remove oldest
                    }
                    
                    this.audioBuffer.push(audioChunk);
                    
                } catch (error) {
                    console.error('Binary message error:', error);
                }
            }
            
            handleServerMessage(data) {
                switch (data.type) {
                    case 'init':
                        this.clientId = data.client_id;
                        this.sampleRate = data.sample_rate;
                        this.log(`Initialized as ${this.clientId}`);
                        break;
                        
                    case 'pong':
                        if (data.client_time) {
                            const currentTime = performance.now() / 1000;
                            this.latency = (currentTime - data.client_time) * 1000;
                            this.latencyElement.textContent = Math.round(this.latency) + 'ms';
                        }
                        break;
                        
                    case 'sync':
                        this.handleSyncMessage(data);
                        break;
                        
                    case 'buffer_adjust':
                        this.targetBufferSize = Math.ceil(data.target_buffer_ms / 1000 * this.sampleRate / 256);
                        this.log(`Buffer adjusted to ${data.target_buffer_ms}ms`);
                        break;
                }
            }
            
            handleSyncMessage(data) {
                if (data.server_time) {
                    const currentTime = performance.now() / 1000;
                    const offset = currentTime - data.server_time;
                    
                    this.clockSyncSamples.push(offset);
                    if (this.clockSyncSamples.length > 5) {
                        this.clockSyncSamples.shift();
                    }
                    
                    this.serverTimeOffset = this.clockSyncSamples.reduce((a, b) => a + b) / this.clockSyncSamples.length;
                }
            }
            
            startLatencyMeasurement() {
                this.pingInterval = setInterval(() => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        const pingData = {
                            type: 'ping',
                            client_time: performance.now() / 1000,
                            client_id: this.clientId
                        };
                        this.ws.send(JSON.stringify(pingData));
                    }
                }, 2000); // Every 2 seconds
            }
            
            stopLatencyMeasurement() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
            }
            
            updateMetrics() {
                // Update buffer status
                this.bufferElement.textContent = this.audioBuffer.length;
                
                // Update quality based on packet loss
                const lossRate = this.packetsReceived > 0 ? (this.packetsLost / this.packetsReceived) * 100 : 0;
                let quality;
                
                if (lossRate < 0.1) {
                    quality = 'Excellent';
                } else if (lossRate < 1) {
                    quality = 'Good';
                } else if (lossRate < 5) {
                    quality = 'Fair';
                } else {
                    quality = 'Poor';
                }
                
                this.qualityElement.textContent = quality;
                
                // Send buffer status to server
                if (this.ws && this.ws.readyState === WebSocket.OPEN && this.packetsReceived % 50 === 0) {
                    const status = {
                        type: 'buffer_status',
                        buffer_size: this.audioBuffer.length,
                        packets_received: this.packetsReceived,
                        packets_lost: this.packetsLost,
                        client_id: this.clientId
                    };
                    this.ws.send(JSON.stringify(status));
                }
            }
            
            updateConnectionStatus(status) {
                this.connectionStatus.textContent = status;
                this.statusElement.innerHTML = status + ' <span class="status-indicator status-' + 
                    (status === 'Connected' ? 'good' : 'error') + '"></span>';
            }
            
            updateVisualizer(samples) {
                if (!samples || samples.length === 0) return;
                
                const chunkSize = Math.floor(samples.length / this.visualizerBars.length);
                
                for (let i = 0; i < this.visualizerBars.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < chunkSize; j++) {
                        const index = i * chunkSize + j;
                        if (index < samples.length) {
                            sum += Math.abs(samples[index]);
                        }
                    }
                    const average = sum / chunkSize;
                    const height = Math.max(1, Math.min(50, average * 200));
                    this.visualizerBars[i].style.height = height + 'px';
                }
            }
            
            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[${timestamp}] ${message}`;
                this.statusLog.textContent = logMessage;
                console.log(logMessage);
            }
        }
        
        // Initialize client when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new UltraLowLatencyAudioClient();
        });
    </script>
</body>
</html>